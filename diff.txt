diff --git a/diff.txt b/diff.txt
new file mode 100644
index 0000000..e69de29
diff --git a/src/main/java/com/szu/afternoon3/platform/common/UserContext.java b/src/main/java/com/szu/afternoon3/platform/common/UserContext.java
index cbfa89e..8333828 100644
--- a/src/main/java/com/szu/afternoon3/platform/common/UserContext.java
+++ b/src/main/java/com/szu/afternoon3/platform/common/UserContext.java
@@ -6,19 +6,29 @@ package com.szu.afternoon3.platform.common;
  */
 public class UserContext {
     private static final ThreadLocal<Long> USER_HOLDER = new ThreadLocal<>();
+    // 【新增】存储当前用户的角色
+    private static final ThreadLocal<String> ROLE_HOLDER = new ThreadLocal<>();
 
-    // 存入 UserId
     public static void setUserId(Long userId) {
         USER_HOLDER.set(userId);
     }
 
-    // 获取 UserId
     public static Long getUserId() {
         return USER_HOLDER.get();
     }
 
-    // 清除
+    // 【新增】
+    public static void setRole(String role) {
+        ROLE_HOLDER.set(role);
+    }
+
+    // 【新增】
+    public static String getRole() {
+        return ROLE_HOLDER.get();
+    }
+
     public static void clear() {
         USER_HOLDER.remove();
+        ROLE_HOLDER.remove(); // 【新增】
     }
 }
\ No newline at end of file
diff --git a/src/main/java/com/szu/afternoon3/platform/config/AdminInterceptor.java b/src/main/java/com/szu/afternoon3/platform/config/AdminInterceptor.java
new file mode 100644
index 0000000..53eebf1
--- /dev/null
+++ b/src/main/java/com/szu/afternoon3/platform/config/AdminInterceptor.java
@@ -0,0 +1,31 @@
+package com.szu.afternoon3.platform.config;
+
+import com.szu.afternoon3.platform.common.UserContext;
+import com.szu.afternoon3.platform.exception.AppException;
+import com.szu.afternoon3.platform.exception.ResultCode;
+import jakarta.servlet.http.HttpServletRequest;
+import jakarta.servlet.http.HttpServletResponse;
+import lombok.extern.slf4j.Slf4j;
+import org.springframework.stereotype.Component;
+import org.springframework.web.servlet.HandlerInterceptor;
+
+@Component
+@Slf4j
+public class AdminInterceptor implements HandlerInterceptor {
+
+    @Override
+    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
+        // 1. 获取当前角色 (由 TokenInterceptor 解析并放入上下文)
+        String role = UserContext.getRole();
+
+        // 2. 鉴权：必须是 ADMIN
+        if (!"ADMIN".equals(role)) {
+            log.warn("越权访问拦截: UserID={}, Role={}, URL={}", 
+                     UserContext.getUserId(), role, request.getRequestURI());
+            throw new AppException(ResultCode.PERMISSION_DENIED, "非管理员无权操作");
+        }
+
+        // 3. 放行
+        return true;
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/com/szu/afternoon3/platform/config/AsyncConfig.java b/src/main/java/com/szu/afternoon3/platform/config/AsyncConfig.java
index 5d32be5..555d385 100644
--- a/src/main/java/com/szu/afternoon3/platform/config/AsyncConfig.java
+++ b/src/main/java/com/szu/afternoon3/platform/config/AsyncConfig.java
@@ -1,5 +1,6 @@
 package com.szu.afternoon3.platform.config;
 
+import com.szu.afternoon3.platform.common.UserContext;
 import org.slf4j.MDC;
 import org.springframework.context.annotation.Configuration;
 import org.springframework.scheduling.annotation.AsyncConfigurer;
@@ -21,18 +22,21 @@ public class AsyncConfig implements AsyncConfigurer {
         
         // 【核心】设置任务装饰器，把主线程的 MDC 拷贝给子线程
         executor.setTaskDecorator(runnable -> {
-            // 1. 捕获主线程的上下文
-            Map<String, String> context = MDC.getCopyOfContextMap();
+            // 1. 捕获主线程上下文
+            Map<String, String> mdcContext = MDC.getCopyOfContextMap();
+            Long userId = UserContext.getUserId(); // <--- 捕获 UserId
+
             return () -> {
                 try {
-                    // 2. 注入到子线程
-                    if (context != null) {
-                        MDC.setContextMap(context);
-                    }
+                    // 2. 注入子线程
+                    if (mdcContext != null) MDC.setContextMap(mdcContext);
+                    if (userId != null) UserContext.setUserId(userId); // <--- 注入
+
                     runnable.run();
                 } finally {
-                    // 3. 清理子线程
+                    // 3. 清理
                     MDC.clear();
+                    UserContext.clear(); // <--- 清理
                 }
             };
         });
diff --git a/src/main/java/com/szu/afternoon3/platform/config/TokenInterceptor.java b/src/main/java/com/szu/afternoon3/platform/config/TokenInterceptor.java
index 688ba88..040c655 100644
--- a/src/main/java/com/szu/afternoon3/platform/config/TokenInterceptor.java
+++ b/src/main/java/com/szu/afternoon3/platform/config/TokenInterceptor.java
@@ -78,9 +78,13 @@ public class TokenInterceptor implements HandlerInterceptor {
             }
             Long userId = Long.valueOf(userIdObj.toString());
 
+            // 【新增】解析 Role 并放入上下文
+            Object roleObj = jwt.getPayload("role");
+            String role = (roleObj != null) ? roleObj.toString() : "USER"; // 默认 USER 防空指针
+
             // 8. 放入 ThreadLocal
             UserContext.setUserId(userId);
-
+            UserContext.setRole(role);
             // 放行
             return true;
 
diff --git a/src/main/java/com/szu/afternoon3/platform/config/WebMvcConfig.java b/src/main/java/com/szu/afternoon3/platform/config/WebMvcConfig.java
index 415ce3b..17a8ad9 100644
--- a/src/main/java/com/szu/afternoon3/platform/config/WebMvcConfig.java
+++ b/src/main/java/com/szu/afternoon3/platform/config/WebMvcConfig.java
@@ -22,7 +22,8 @@ public class WebMvcConfig implements WebMvcConfigurer {
 
     @Autowired
     private RequestIdInterceptor requestIdInterceptor;
-
+    @Autowired
+    private AdminInterceptor adminInterceptor;
     // 1. 配置拦截器
     @Override
     public void addInterceptors(InterceptorRegistry registry) {
@@ -33,26 +34,26 @@ public class WebMvcConfig implements WebMvcConfigurer {
                 .order(Ordered.HIGHEST_PRECEDENCE); // 设置最高优先级，保证第一个执行
 
         registry.addInterceptor(tokenInterceptor)
-                .addPathPatterns("/api/**") // 默认拦截 api 下的所有路径
+                .addPathPatterns("/api/**","/admin/**") // 默认拦截 api 下的所有路径
                 // 排除不需要登录的接口
                 .excludePathPatterns(
                         "/api/auth/**",      // 登录注册
                         "/api/common/**",    // 公共接口
-
+                        "/admin/auth/**",
                         // TODO 当前逻辑是从token中获取userId,如果直接放行就无法从上下文获取userId。之后加入柔性放行策略
-                        // --- 新增：放行内容浏览类接口 ---
-//                        "/api/post/list",    // 首页列表
-//                        "/api/post/search",  // 搜索
-//                        "/api/post/*",       // 帖子详情 (匹配 /api/post/xxxx)
-//                        "/api/tag/**",       // 标签相关
-
                         // --- Swagger/静态资源 ---
                         "/doc.html",
                         "/webjars/**",
                         "/v3/api-docs/**",
                         "/swagger-resources/**",
                         "/actuator/**"
-                );
+                )
+                .order(1);
+        //Admin 权限拦截器 (依赖 Token 拦截器的结果)
+        registry.addInterceptor(adminInterceptor)
+                .addPathPatterns("/admin/**") // 只拦截后台接口
+                .excludePathPatterns("/admin/auth/**")
+                .order(2); // 顺序必须在 TokenInterceptor 之后
     }
 
     // 2. 配置跨域
diff --git a/src/main/java/com/szu/afternoon3/platform/controller/AdminController.java b/src/main/java/com/szu/afternoon3/platform/controller/AdminController.java
index 515796a..4754e79 100644
--- a/src/main/java/com/szu/afternoon3/platform/controller/AdminController.java
+++ b/src/main/java/com/szu/afternoon3/platform/controller/AdminController.java
@@ -4,9 +4,12 @@ import com.szu.afternoon3.platform.common.Result;
 import com.szu.afternoon3.platform.dto.*;
 import com.szu.afternoon3.platform.service.AdminService;
 import com.szu.afternoon3.platform.service.AuthService;
+import com.szu.afternoon3.platform.service.UserService;
+import com.szu.afternoon3.platform.vo.AdminUserDetailVO;
 import com.szu.afternoon3.platform.vo.LoginVO;
 import com.szu.afternoon3.platform.vo.PostVO;
 import com.szu.afternoon3.platform.vo.UserInfo;
+import jakarta.servlet.http.HttpServletRequest;
 import jakarta.validation.Valid;
 import org.springframework.beans.factory.annotation.Autowired;
 import org.springframework.web.bind.annotation.*;
@@ -14,7 +17,7 @@ import org.springframework.web.bind.annotation.*;
 import java.util.Map;
 
 @RestController
-@RequestMapping("/api/admin")
+@RequestMapping("/admin")
 public class AdminController {
 
     @Autowired
@@ -23,61 +26,94 @@ public class AdminController {
     @Autowired
     private AuthService authService; // 复用 resetPassword 逻辑
 
-    @PostMapping("/login")
+    @Autowired
+    private UserService userService;
+
+    @PostMapping("/auth/login")
     public Result<LoginVO> login(@RequestBody @Valid AccountLoginDTO loginDTO) {
         LoginVO loginVO = adminService.login(loginDTO.getAccount(), loginDTO.getPassword());
         return Result.success(loginVO);
     }
 
-    @GetMapping("/me")
-    public Result<UserInfo> getAdminInfo() {
-        return Result.success(adminService.getAdminInfo());
+    @PostMapping("/auth/send-code")
+    public Result<Void> sendCode(@RequestBody @Valid SendEmailCodeDTO dto) {
+        // 复用 AuthService 的发送逻辑
+        authService.sendEmailCode(dto.getEmail());
+        return Result.success();
     }
 
     // 管理员修改密码 (通过邮箱验证码)
-    // 复用 UserPasswordResetDTO (email, code, newPassword)
-    // 注意：虽然是“修改密码”，但业务流程是“重置密码”流程
-    @PostMapping("/password/change")
+    @PostMapping("/auth/reset-password")
     public Result<Void> changePassword(@RequestBody @Valid UserPasswordResetDTO dto) {
-        // 这里直接复用 AuthService 的 resetPassword，因为它就是 email+code+newPwd
-        // 也可以在 AdminService 里包一层，确保是改自己的？
-        // 既然输入了 email 和 code，且验证通过，那就是安全的。
         authService.resetPassword(dto);
         return Result.success();
     }
 
+    // 退出登录 (补充文档中存在的接口)
+    @PostMapping("/auth/logout")
+    public Result<Void> logout(HttpServletRequest request) {
+        String token = request.getHeader("Authorization");
+        if (token != null && token.startsWith("Bearer ")) {
+            authService.logout(token.substring(7));
+        }
+        return Result.success();
+    }
+
+    // 个人信息
+    @GetMapping("/profile/info")
+    public Result<UserInfo> getAdminInfo() {
+        return Result.success(adminService.getAdminInfo());
+    }
+
+    // 登录之后重置密码
+    @PostMapping("/profile/password")
+    public Result<Void> updatePassword(@RequestBody @Valid UserPasswordChangeDTO dto) {
+        // 校验旧密码 -> 更新新密码
+        // 注意：这里可以直接复用 UserService 的逻辑，因为 Admin 也是 User 表里的
+        // 或者在 AdminService 再包一层
+        userService.changePassword(dto);
+        return Result.success();
+    }
+
+
+
     // 用户管理 - 列表
-    @PostMapping("/users/list")
+    @PostMapping("/user/list")
     public Result<Map<String, Object>> getUserList(@RequestBody AdminUserSearchDTO dto) {
         return Result.success(adminService.getUserList(dto));
     }
 
+    // 获取用户详情 (聚合视图)
+    @GetMapping("/users/{id}")
+    public Result<AdminUserDetailVO> getUserDetail(@PathVariable Long id) {
+        return Result.success(adminService.getUserDetail(id));
+    }
+
     // 用户管理 - 删除
-    @PostMapping("/users/{id}/delete")
-    public Result<Void> deleteUser(@PathVariable Long id, @RequestBody Map<String, String> body) {
-        String reason = body.get("reason");
-        adminService.deleteUser(id, reason);
+    @PostMapping("/user/{id}")
+    public Result<Void> deleteUser(@PathVariable Long id, @RequestBody @Valid AdminUserDeleteDTO dto) {
+        // 使用 DTO.getReason()，类型安全且由 Spring 自动校验非空
+        adminService.deleteUser(id, dto.getReason());
         return Result.success();
     }
 
     // 内容审核 - 列表
-    @PostMapping("/posts/list")
+    @PostMapping("/post/audit-list")
     public Result<Map<String, Object>> getPostList(@RequestBody AdminPostSearchDTO dto) {
         return Result.success(adminService.getPostList(dto));
     }
 
     // 内容审核 - 详情
-    @GetMapping("/posts/{id}")
+    @GetMapping("/post/{id}")
     public Result<PostVO> getPostDetail(@PathVariable String id) {
         return Result.success(adminService.getPostDetail(id));
     }
 
     // 内容审核 - 审核
-    @PostMapping("/posts/{id}/audit")
-    public Result<Void> auditPost(@PathVariable String id, @RequestBody Map<String, Object> body) {
-        Integer status = (Integer) body.get("status");
-        String reason = (String) body.get("reason");
-        adminService.auditPost(id, status, reason);
+    @PostMapping("/post/{id}/audit")
+    public Result<Void> auditPost(@PathVariable String id, @RequestBody @Valid AdminPostAuditDTO dto) {
+        // 使用 DTO 获取参数
+        adminService.auditPost(id, dto.getStatus(), dto.getReason());
         return Result.success();
     }
 }
diff --git a/src/main/java/com/szu/afternoon3/platform/dto/AdminPostAuditDTO.java b/src/main/java/com/szu/afternoon3/platform/dto/AdminPostAuditDTO.java
new file mode 100644
index 0000000..521ddd1
--- /dev/null
+++ b/src/main/java/com/szu/afternoon3/platform/dto/AdminPostAuditDTO.java
@@ -0,0 +1,12 @@
+package com.szu.afternoon3.platform.dto;
+
+import jakarta.validation.constraints.NotNull;
+import lombok.Data;
+
+@Data
+public class AdminPostAuditDTO {
+    @NotNull(message = "审核状态不能为空")
+    private Integer status; // 1:通过, 2:拒绝
+
+    private String reason; // 拒绝理由（选填）
+}
\ No newline at end of file
diff --git a/src/main/java/com/szu/afternoon3/platform/dto/AdminUserDeleteDTO.java b/src/main/java/com/szu/afternoon3/platform/dto/AdminUserDeleteDTO.java
new file mode 100644
index 0000000..0af53cf
--- /dev/null
+++ b/src/main/java/com/szu/afternoon3/platform/dto/AdminUserDeleteDTO.java
@@ -0,0 +1,11 @@
+package com.szu.afternoon3.platform.dto;
+
+import jakarta.validation.constraints.NotBlank;
+import lombok.Data;
+
+@Data
+public class AdminUserDeleteDTO {
+    // 必填，用于记录日志或通知用户
+    @NotBlank(message = "删除原因不能为空")
+    private String reason;
+}
\ No newline at end of file
diff --git a/src/main/java/com/szu/afternoon3/platform/event/UserDeleteEvent.java b/src/main/java/com/szu/afternoon3/platform/event/UserDeleteEvent.java
new file mode 100644
index 0000000..fe0d673
--- /dev/null
+++ b/src/main/java/com/szu/afternoon3/platform/event/UserDeleteEvent.java
@@ -0,0 +1,14 @@
+package com.szu.afternoon3.platform.event;
+
+import lombok.Getter;
+import org.springframework.context.ApplicationEvent;
+
+@Getter
+public class UserDeleteEvent extends ApplicationEvent {
+    private final Long userId;
+
+    public UserDeleteEvent(Object source, Long userId) {
+        super(source);
+        this.userId = userId;
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/com/szu/afternoon3/platform/event/UserSearchEvent.java b/src/main/java/com/szu/afternoon3/platform/event/UserSearchEvent.java
new file mode 100644
index 0000000..23210c3
--- /dev/null
+++ b/src/main/java/com/szu/afternoon3/platform/event/UserSearchEvent.java
@@ -0,0 +1,16 @@
+package com.szu.afternoon3.platform.event;
+
+import lombok.Getter;
+import org.springframework.context.ApplicationEvent;
+
+@Getter
+public class UserSearchEvent extends ApplicationEvent {
+    private final Long userId;
+    private final String keyword;
+
+    public UserSearchEvent(Object source, Long userId, String keyword) {
+        super(source);
+        this.userId = userId;
+        this.keyword = keyword;
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/com/szu/afternoon3/platform/listener/SearchEventListener.java b/src/main/java/com/szu/afternoon3/platform/listener/SearchEventListener.java
new file mode 100644
index 0000000..f1a14a4
--- /dev/null
+++ b/src/main/java/com/szu/afternoon3/platform/listener/SearchEventListener.java
@@ -0,0 +1,56 @@
+package com.szu.afternoon3.platform.listener;
+
+import com.szu.afternoon3.platform.entity.mongo.SearchHistoryDoc;
+import com.szu.afternoon3.platform.event.UserSearchEvent;
+import lombok.extern.slf4j.Slf4j;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.context.event.EventListener;
+import org.springframework.data.mongodb.core.MongoTemplate;
+import org.springframework.data.mongodb.core.query.Criteria;
+import org.springframework.data.mongodb.core.query.Query;
+import org.springframework.data.mongodb.core.query.Update;
+import org.springframework.scheduling.annotation.Async;
+import org.springframework.stereotype.Component;
+
+import java.time.LocalDateTime;
+
+@Component
+@Slf4j
+public class SearchEventListener {
+
+    @Autowired
+    private MongoTemplate mongoTemplate;
+
+    @Async("taskExecutor") // 显式指定线程池(如果在AsyncConfig配置了的话)，或者直接用@Async
+    @EventListener
+    public void handleSearchEvent(UserSearchEvent event) {
+        Long userId = event.getUserId();
+        String keyword = event.getKeyword();
+
+        // 简单的判空，防止无效记录
+        if (userId == null || keyword == null || keyword.trim().isEmpty()) {
+            return;
+        }
+
+        try {
+            // 1. 定义查询条件: userId + keyword (利用唯一索引)
+            Query query = new Query(Criteria.where("userId").is(userId).and("keyword").is(keyword));
+
+            // 2. 定义更新: 更新时间
+            Update update = new Update();
+            update.set("updatedAt", LocalDateTime.now());
+            // 如果是新插入，Mongo会自动设置 userId 和 keyword (因为在Query里)
+            // 但为了保险，显式setOnInsert一下
+            update.setOnInsert("userId", userId);
+            update.setOnInsert("keyword", keyword);
+
+            // 3. 执行 Upsert (存在则更新时间，不存在则插入)
+            mongoTemplate.upsert(query, update, SearchHistoryDoc.class);
+            
+            // log.debug("异步保存搜索历史成功: user={}, keyword={}", userId, keyword);
+
+        } catch (Exception e) {
+            log.warn("保存搜索历史失败: {}", e.getMessage());
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/com/szu/afternoon3/platform/listener/UserEventListener.java b/src/main/java/com/szu/afternoon3/platform/listener/UserEventListener.java
index 2910c2e..937c171 100644
--- a/src/main/java/com/szu/afternoon3/platform/listener/UserEventListener.java
+++ b/src/main/java/com/szu/afternoon3/platform/listener/UserEventListener.java
@@ -1,8 +1,7 @@
 package com.szu.afternoon3.platform.listener;
 
-import com.szu.afternoon3.platform.entity.mongo.CommentDoc;
-import com.szu.afternoon3.platform.entity.mongo.PostDoc;
-import com.szu.afternoon3.platform.entity.mongo.UserFollowDoc;
+import com.szu.afternoon3.platform.entity.mongo.*;
+import com.szu.afternoon3.platform.event.UserDeleteEvent;
 import com.szu.afternoon3.platform.event.UserUpdateEvent;
 import lombok.extern.slf4j.Slf4j;
 import org.springframework.beans.factory.annotation.Autowired;
@@ -91,4 +90,43 @@ public class UserEventListener {
 
         log.info("MongoDB 数据同步完成 (异步)");
     }
+
+    /**
+     * 处理用户注销/删除事件：清理 MongoDB 中的所有关联数据
+     */
+    @Async // 关键：异步执行，不阻塞管理员接口
+    @EventListener
+    public void handleUserDelete(UserDeleteEvent event) {
+        Long userId = event.getUserId();
+        log.info("开始异步清理用户数据: userId={}", userId);
+        long start = System.currentTimeMillis();
+
+        // 1. 删除该用户发布的帖子
+        mongoTemplate.remove(Query.query(Criteria.where("userId").is(userId)), PostDoc.class);
+
+        // 2. 删除该用户发布的评论
+        mongoTemplate.remove(Query.query(Criteria.where("userId").is(userId)), CommentDoc.class);
+
+        // 3. 删除该用户的点赞记录
+        mongoTemplate.remove(Query.query(Criteria.where("userId").is(userId)), PostLikeDoc.class);
+        mongoTemplate.remove(Query.query(Criteria.where("userId").is(userId)), CommentLikeDoc.class);
+
+        // 4. 删除该用户的收藏记录
+        mongoTemplate.remove(Query.query(Criteria.where("userId").is(userId)), PostCollectDoc.class);
+
+        // 5. 删除该用户的评分记录
+        mongoTemplate.remove(Query.query(Criteria.where("userId").is(userId)), PostRatingDoc.class);
+
+        // 6. 删除该用户的关注关系 (作为粉丝)
+        mongoTemplate.remove(Query.query(Criteria.where("userId").is(userId)), UserFollowDoc.class);
+
+        // 7. 删除该用户的被关注关系 (作为博主) - 可选：也可以保留记录但把 targetUser 信息置空，直接删比较干净
+        mongoTemplate.remove(Query.query(Criteria.where("targetUserId").is(userId)), UserFollowDoc.class);
+
+        // 8. 删除搜索历史 & 浏览历史
+        mongoTemplate.remove(Query.query(Criteria.where("userId").is(userId)), SearchHistoryDoc.class);
+        mongoTemplate.remove(Query.query(Criteria.where("userId").is(userId)), PostViewHistoryDoc.class);
+
+        log.info("用户数据清理完成，耗时: {}ms", System.currentTimeMillis() - start);
+    }
 }
\ No newline at end of file
diff --git a/src/main/java/com/szu/afternoon3/platform/service/AdminService.java b/src/main/java/com/szu/afternoon3/platform/service/AdminService.java
index c89cfb8..4610c69 100644
--- a/src/main/java/com/szu/afternoon3/platform/service/AdminService.java
+++ b/src/main/java/com/szu/afternoon3/platform/service/AdminService.java
@@ -18,6 +18,9 @@ public interface AdminService {
     // 用户管理 - 删除用户
     void deleteUser(Long userId, String reason);
 
+    // 聚合用户详情
+    public AdminUserDetailVO getUserDetail(Long userId);
+
     // 内容审核 - 列表查询
     Map<String, Object> getPostList(AdminPostSearchDTO dto);
 
diff --git a/src/main/java/com/szu/afternoon3/platform/service/impl/AdminServiceImpl.java b/src/main/java/com/szu/afternoon3/platform/service/impl/AdminServiceImpl.java
index 6a60cf8..91c72fd 100644
--- a/src/main/java/com/szu/afternoon3/platform/service/impl/AdminServiceImpl.java
+++ b/src/main/java/com/szu/afternoon3/platform/service/impl/AdminServiceImpl.java
@@ -1,5 +1,6 @@
 package com.szu.afternoon3.platform.service.impl;
 
+import cn.hutool.core.collection.CollUtil;
 import cn.hutool.core.util.StrUtil;
 import cn.hutool.crypto.digest.BCrypt;
 import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;
@@ -8,8 +9,13 @@ import com.baomidou.mybatisplus.extension.plugins.pagination.Page;
 import com.szu.afternoon3.platform.common.UserContext;
 import com.szu.afternoon3.platform.dto.*;
 import com.szu.afternoon3.platform.entity.User;
+import com.szu.afternoon3.platform.entity.mongo.PostCollectDoc;
 import com.szu.afternoon3.platform.entity.mongo.PostDoc;
+import com.szu.afternoon3.platform.entity.mongo.PostLikeDoc;
 import com.szu.afternoon3.platform.entity.mongo.UserFollowDoc;
+import com.szu.afternoon3.platform.entity.mongo.PostRatingDoc;
+import com.szu.afternoon3.platform.entity.mongo.CommentDoc;
+import com.szu.afternoon3.platform.event.UserDeleteEvent;
 import com.szu.afternoon3.platform.exception.AppException;
 import com.szu.afternoon3.platform.exception.ResultCode;
 import com.szu.afternoon3.platform.mapper.UserMapper;
@@ -22,6 +28,7 @@ import com.szu.afternoon3.platform.vo.*;
 import lombok.extern.slf4j.Slf4j;
 import org.springframework.beans.BeanUtils;
 import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.context.ApplicationEventPublisher;
 import org.springframework.data.domain.PageRequest;
 import org.springframework.data.domain.Pageable;
 import org.springframework.data.domain.Sort;
@@ -37,10 +44,7 @@ import org.springframework.transaction.annotation.Transactional;
 
 import java.time.LocalDateTime;
 import java.time.LocalTime;
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
+import java.util.*;
 import java.util.stream.Collectors;
 
 @Service
@@ -62,7 +66,8 @@ public class AdminServiceImpl implements AdminService {
     private UserFollowRepository userFollowRepository;
     @Autowired
     private MongoTemplate mongoTemplate;
-
+    @Autowired
+    private ApplicationEventPublisher eventPublisher;
     @Override
     public LoginVO login(String account, String password) {
         // 1. 查询用户
@@ -94,7 +99,7 @@ public class AdminServiceImpl implements AdminService {
     }
 
     private LoginVO buildLoginVO(User user) {
-        String token = jwtUtil.createToken(user.getId());
+        String token = jwtUtil.createToken(user.getId(), user.getRole());
         LoginVO vo = new LoginVO();
         vo.setToken(token);
         vo.setHasPassword(true);
@@ -133,26 +138,9 @@ public class AdminServiceImpl implements AdminService {
         return info;
     }
 
-    // 为了满足“显示用户组身份及注册时间”，我们可能需要返回更详细的VO
-    // 暂时先用 UserInfo，如果前端需要 createdAt，可以扩展 UserInfo 或返回 Map
-    // 既然要求严格，我直接扩展一个 AdminProfileVO 吧，或者用 Map 返回
-
-    public Map<String, Object> getAdminProfileFull() {
-        Long userId = UserContext.getUserId();
-        User user = userMapper.selectById(userId);
-        Map<String, Object> map = new HashMap<>();
-        map.put("userId", user.getId().toString());
-        map.put("nickname", user.getNickname());
-        map.put("avatar", user.getAvatar());
-        map.put("email", user.getEmail());
-        map.put("role", user.getRole());
-        map.put("createdAt", user.getCreatedAt());
-        return map;
-    }
-
     @Override
     public Map<String, Object> getUserList(AdminUserSearchDTO dto) {
-        // MyBatis Plus 分页
+        // 1. [PostgreSQL] 查询用户基础分页数据
         Page<User> page = new Page<>(dto.getPage(), dto.getSize());
         LambdaQueryWrapper<User> wrapper = new LambdaQueryWrapper<>();
 
@@ -169,18 +157,88 @@ public class AdminServiceImpl implements AdminService {
             wrapper.le(User::getCreatedAt, dto.getEndTime().atTime(LocalTime.MAX));
         }
 
-        // 只查询普通用户? 需求没说，通常包括所有用户。
-
         IPage<User> userPage = userMapper.selectPage(page, wrapper);
+        List<User> userList = userPage.getRecords();
+
+        // 快速返回：如果没有用户，直接返回空，避免后续 Mongo 报错
+        if (userList.isEmpty()) {
+            Map<String, Object> emptyResult = new HashMap<>();
+            emptyResult.put("records", new ArrayList<>());
+            emptyResult.put("total", 0L);
+            return emptyResult;
+        }
 
+        // 2. 提取本页所有用户的 ID 列表
+        List<Long> userIds = userList.stream().map(User::getId).collect(Collectors.toList());
+
+        // 3. [MongoDB] 批量聚合查询统计数据 (使用 $in 操作符)
+
+        // 3.1 批量查询：帖子数、获赞数、平均分 (数据源: posts)
+        // Group by userId, Count(id), Sum(likeCount), Avg(ratingAverage)
+        Aggregation postAgg = Aggregation.newAggregation(
+                Aggregation.match(Criteria.where("userId").in(userIds).and("isDeleted").is(0)),
+                Aggregation.group("userId")
+                        .count().as("postCount")
+                        .sum("likeCount").as("totalLikes")
+                        .avg("ratingAverage").as("avgScore")
+        );
+        // 结果转 Map: userId -> 统计对象
+        Map<Long, Map> postStatsMap = mongoTemplate.aggregate(postAgg, PostDoc.class, Map.class)
+                .getMappedResults().stream()
+                .collect(Collectors.toMap(
+                        item -> ((Number) item.get("_id")).longValue(), // Key: userId
+                        item -> item // Value: 整个统计结果
+                ));
+
+        // 3.2 批量查询：粉丝数 (数据源: user_follows, targetUserId IN userIds)
+        Aggregation fanAgg = Aggregation.newAggregation(
+                Aggregation.match(Criteria.where("targetUserId").in(userIds)),
+                Aggregation.group("targetUserId").count().as("count")
+        );
+        Map<Long, Long> fanCountMap = mongoTemplate.aggregate(fanAgg, UserFollowDoc.class, Map.class)
+                .getMappedResults().stream()
+                .collect(Collectors.toMap(
+                        item -> ((Number) item.get("_id")).longValue(),
+                        item -> ((Number) item.get("count")).longValue()
+                ));
+
+        // 3.3 批量查询：关注数 (数据源: user_follows, userId IN userIds)
+        Aggregation followAgg = Aggregation.newAggregation(
+                Aggregation.match(Criteria.where("userId").in(userIds)),
+                Aggregation.group("userId").count().as("count")
+        );
+        Map<Long, Long> followCountMap = mongoTemplate.aggregate(followAgg, UserFollowDoc.class, Map.class)
+                .getMappedResults().stream()
+                .collect(Collectors.toMap(
+                        item -> ((Number) item.get("_id")).longValue(),
+                        item -> ((Number) item.get("count")).longValue()
+                ));
+
+        // 4. [内存] 组装最终 VO
         List<AdminUserVO> records = new ArrayList<>();
-        for (User user : userPage.getRecords()) {
+        for (User user : userList) {
             AdminUserVO vo = new AdminUserVO();
             BeanUtils.copyProperties(user, vo);
             vo.setRegisterTime(user.getCreatedAt());
 
-            // 统计数据
-            fillUserStats(vo, user.getId());
+            Long uid = user.getId();
+
+            // 填充帖子相关数据 (从 Map 获取，避免空指针)
+            Map stats = postStatsMap.get(uid);
+            if (stats != null) {
+                vo.setPostCount(stats.get("postCount") != null ? ((Number) stats.get("postCount")).longValue() : 0L);
+                vo.setLikeCount(stats.get("totalLikes") != null ? ((Number) stats.get("totalLikes")).longValue() : 0L);
+                vo.setAvgScore(stats.get("avgScore") != null ? ((Number) stats.get("avgScore")).doubleValue() : 0.0);
+            } else {
+                vo.setPostCount(0L);
+                vo.setLikeCount(0L);
+                vo.setAvgScore(0.0);
+            }
+
+            // 填充粉丝/关注
+            vo.setFanCount(fanCountMap.getOrDefault(uid, 0L));
+            vo.setFollowCount(followCountMap.getOrDefault(uid, 0L));
+
             records.add(vo);
         }
 
@@ -190,101 +248,100 @@ public class AdminServiceImpl implements AdminService {
         return result;
     }
 
-    private void fillUserStats(AdminUserVO vo, Long userId) {
-        // 1. 帖子数
-        long postCount = mongoTemplate.count(new Query(Criteria.where("userId").is(userId).and("isDeleted").is(0)),
-                PostDoc.class);
-        vo.setPostCount(postCount);
-
-        // 2. 粉丝数 (关注我的人)
-        long fanCount = mongoTemplate.count(new Query(Criteria.where("targetUserId").is(userId)), UserFollowDoc.class);
-        vo.setFanCount(fanCount);
-
-        // 3. 关注数 (我关注的人)
-        long followCount = mongoTemplate.count(new Query(Criteria.where("userId").is(userId)), UserFollowDoc.class);
-        vo.setFollowCount(followCount);
-
-        // 4. 获赞数 & 均分 (聚合查询)
-        // 聚合 PostDoc，match userId, sum likeCount, avg ratingAverage
-        Aggregation agg = Aggregation.newAggregation(
-                Aggregation.match(Criteria.where("userId").is(userId).and("isDeleted").is(0)),
-                Aggregation.group().sum("likeCount").as("totalLikes").avg("ratingAverage").as("avgScore"));
-
-        AggregationResults<Map> results = mongoTemplate.aggregate(agg, "posts", Map.class);
-        Map map = results.getUniqueMappedResult();
-
-        if (map != null) {
-            Number totalLikes = (Number) map.get("totalLikes");
-            Number avgScore = (Number) map.get("avgScore");
-            vo.setLikeCount(totalLikes != null ? totalLikes.longValue() : 0L);
-            vo.setAvgScore(avgScore != null ? avgScore.doubleValue() : 0.0);
-        } else {
-            vo.setLikeCount(0L);
-            vo.setAvgScore(0.0);
-        }
-    }
-
     @Override
+    @Transactional(rollbackFor = Exception.class)
     public void deleteUser(Long userId, String reason) {
-        // 逻辑删除
+        // 1. 检查用户是否存在
         User user = userMapper.selectById(userId);
-        if (user == null)
+        if (user == null) {
             return;
+        }
 
+        // 2. [PostgreSQL] 物理删除用户 (或逻辑删除，取决于你的 global-config)
+        // MyBatis-Plus 会根据你的配置自动处理逻辑删除
         userMapper.deleteById(userId);
 
-        // 可以在这里记录操作日志 (reason)
-        log.info("Admin deleted user {}: {}", userId, reason);
-    }
+        // 3. [Event] 发布用户删除事件，异步清理 MongoDB 数据
+        // source 传 this，userId 传目标用户ID
+        eventPublisher.publishEvent(new UserDeleteEvent(this, userId));
 
+        log.info("管理员删除用户成功: userId={}, reason={}", userId, reason);
+    }
     @Override
     public Map<String, Object> getPostList(AdminPostSearchDTO dto) {
         Query query = new Query();
 
-        // 筛选未删除
+        // 1. [MongoDB] 构建查询条件
         query.addCriteria(Criteria.where("isDeleted").is(0));
 
-        // 关键词搜索
         if (StrUtil.isNotBlank(dto.getTitleKeyword())) {
             query.addCriteria(Criteria.where("title").regex(dto.getTitleKeyword(), "i"));
         }
-
-        // 标签
         if (dto.getTags() != null && !dto.getTags().isEmpty()) {
             query.addCriteria(Criteria.where("tags").all(dto.getTags()));
         }
-
-        // 时间范围
         if (dto.getStartTime() != null && dto.getEndTime() != null) {
             query.addCriteria(Criteria.where("createdAt")
                     .gte(dto.getStartTime().atStartOfDay())
                     .lte(dto.getEndTime().atTime(LocalTime.MAX)));
         }
 
-        // 用户筛选 (昵称或邮箱)
+        // 特殊处理：按邮箱筛选 (需要先查 PG 拿到 userId)
         if (StrUtil.isNotBlank(dto.getEmail())) {
-            User user = userMapper.selectOne(new LambdaQueryWrapper<User>().eq(User::getEmail, dto.getEmail()));
+            User user = userMapper.selectOne(new LambdaQueryWrapper<User>()
+                    .eq(User::getEmail, dto.getEmail())
+                    .select(User::getId)); // 只查 ID 优化性能
             if (user != null) {
                 query.addCriteria(Criteria.where("userId").is(user.getId()));
             } else {
-                // 查不到用户，直接返回空
                 return Map.of("records", new ArrayList<>(), "total", 0);
             }
         } else if (StrUtil.isNotBlank(dto.getNickname())) {
-            // 模糊匹配昵称 -> 找到一堆 userId
-            // 或者直接用 PostDoc 里的 userNickname (不严谨但快)
-            // 鉴于 PostDoc 有 userNickname，直接查它
+            // 按昵称模糊搜，Mongo 有冗余字段，直接查 Mongo
             query.addCriteria(Criteria.where("userNickname").regex(dto.getNickname(), "i"));
         }
 
-        // 分页
+        // 2. [MongoDB] 执行分页查询
         long total = mongoTemplate.count(query, PostDoc.class);
         Pageable pageable = PageRequest.of(dto.getPage() - 1, dto.getSize(), Sort.by(Sort.Direction.DESC, "createdAt"));
         query.with(pageable);
-
         List<PostDoc> docs = mongoTemplate.find(query, PostDoc.class);
 
-        List<AdminPostVO> records = docs.stream().map(this::convertToAdminPostVO).collect(Collectors.toList());
+        // 3. [PostgreSQL] 批量补全邮箱 (解决 N+1 问题)
+        List<AdminPostVO> records;
+
+        if (CollUtil.isEmpty(docs)) {
+            records = new ArrayList<>();
+        } else {
+            // 3.1 提取所有作者 ID (去重)
+            Set<Long> userIds = docs.stream()
+                    .map(PostDoc::getUserId)
+                    .collect(Collectors.toSet());
+
+            // 3.2 批量查询 PG (SELECT id, email FROM users WHERE id IN (...))
+            List<User> users = userMapper.selectList(new LambdaQueryWrapper<User>()
+                    .in(User::getId, userIds)
+                    .select(User::getId, User::getEmail)); // 只查需要的字段
+
+            // 3.3 转为 Map<UserId, Email> 方便查找
+            Map<Long, String> emailMap = users.stream()
+                    .collect(Collectors.toMap(User::getId, User::getEmail));
+
+            // 3.4 内存组装
+            records = docs.stream().map(doc -> {
+                AdminPostVO vo = new AdminPostVO();
+                BeanUtils.copyProperties(doc, vo);
+
+                // Mongo 里的冗余信息
+                vo.setUserNickname(doc.getUserNickname());
+                vo.setUserAvatar(doc.getUserAvatar());
+
+                // 补全邮箱 (从 Map 取)
+                vo.setUserEmail(emailMap.get(doc.getUserId()));
+
+                return vo;
+            }).collect(Collectors.toList());
+        }
 
         Map<String, Object> result = new HashMap<>();
         result.put("records", records);
@@ -362,4 +419,125 @@ public class AdminServiceImpl implements AdminService {
 
         log.info("Admin audit post {}: status={}, reason={}", postId, status, reason);
     }
+
+    @Override
+    public AdminUserDetailVO getUserDetail(Long userId) {
+        // 1. [PostgreSQL] 查询基础用户信息
+        User user = userMapper.selectById(userId);
+        if (user == null) {
+            throw new AppException(ResultCode.USER_NOT_FOUND);
+        }
+
+        AdminUserDetailVO vo = new AdminUserDetailVO();
+        BeanUtils.copyProperties(user, vo);
+        vo.setRegisterTime(user.getCreatedAt());
+
+        // =====================================================
+        // 2. [MongoDB] 查询主动行为 (Simple Count Queries)
+        // =====================================================
+
+        // 2.1 发帖数 (注意过滤已删除的)
+        long postCount = mongoTemplate.count(
+                Query.query(Criteria.where("userId").is(userId).and("isDeleted").is(0)),
+                PostDoc.class
+        );
+        vo.setPostCount(postCount);
+
+        // 2.2 关注数 (我关注了谁)
+        long followCount = mongoTemplate.count(
+                Query.query(Criteria.where("userId").is(userId)),
+                UserFollowDoc.class
+        );
+        vo.setFollowCount(followCount);
+
+        // 2.3 发出的点赞 (查询 post_likes 表)
+        long givenLike = mongoTemplate.count(
+                Query.query(Criteria.where("userId").is(userId)),
+                PostLikeDoc.class
+        );
+        vo.setGivenLikeCount(givenLike);
+
+        // 2.4 发出的收藏 (查询 post_collects 表)
+        long givenCollect = mongoTemplate.count(
+                Query.query(Criteria.where("userId").is(userId)),
+                PostCollectDoc.class
+        );
+        vo.setGivenCollectCount(givenCollect);
+
+        // 2.5 发出的评论 (查询 comments 表) - [新增实现]
+        long givenComment = mongoTemplate.count(
+                Query.query(Criteria.where("userId").is(userId)),
+                CommentDoc.class
+        );
+        vo.setGivenCommentCount(givenComment);
+
+        // 2.6 发出的评分 (查询 post_ratings 表) - [新增实现]
+        long givenRate = mongoTemplate.count(
+                Query.query(Criteria.where("userId").is(userId)),
+                PostRatingDoc.class
+        );
+        vo.setGivenRateCount(givenRate);
+
+
+        // =====================================================
+        // 3. [MongoDB] 查询被动影响力 (Aggregation)
+        // =====================================================
+
+        // 3.1 粉丝数 (谁关注了我) - 直接查关联表
+        long fanCount = mongoTemplate.count(
+                Query.query(Criteria.where("targetUserId").is(userId)),
+                UserFollowDoc.class
+        );
+        vo.setFanCount(fanCount);
+
+        // 3.2 聚合统计：获得的赞、收藏、评论、平均分
+        // 原理：在 posts 表中找到该用户所有未删除的帖子，对各项计数器求和(Sum)或求平均(Avg)
+        Aggregation agg = Aggregation.newAggregation(
+                // 步骤A: 筛选该用户的有效帖子
+                Aggregation.match(Criteria.where("userId").is(userId).and("isDeleted").is(0)),
+
+                // 步骤B: 全局分组计算
+                Aggregation.group()
+                        .sum("likeCount").as("totalLikes")       // 累加获赞
+                        .sum("collectCount").as("totalCollects") // 累加被收藏
+                        .sum("commentCount").as("totalComments") // 累加被评论 [新增]
+                        .avg("ratingAverage").as("avgScore")     // 计算平均分
+        );
+
+        AggregationResults<Map> results = mongoTemplate.aggregate(agg, PostDoc.class, Map.class);
+        Map<String, Object> map = results.getUniqueMappedResult();
+
+        if (map != null) {
+            // 注意：Mongo聚合返回的数字可能是 Integer, Long 或 Double，建议转 Number 处理
+            vo.setReceivedLikeCount(parseToLong(map.get("totalLikes")));
+            vo.setReceivedCollectCount(parseToLong(map.get("totalCollects")));
+            vo.setReceivedCommentCount(parseToLong(map.get("totalComments"))); // [新增]
+            vo.setAvgPostScore(parseToDouble(map.get("avgScore")));
+        } else {
+            // 如果该用户没发过帖子，各项数据为 0
+            vo.setReceivedLikeCount(0L);
+            vo.setReceivedCollectCount(0L);
+            vo.setReceivedCommentCount(0L);
+            vo.setAvgPostScore(0.0);
+        }
+
+        return vo;
+    }
+
+    // 辅助方法：处理 Mongo 返回的数字类型转换安全问题
+    private Long parseToLong(Object obj) {
+        if (obj instanceof Number) {
+            return ((Number) obj).longValue();
+        }
+        return 0L;
+    }
+
+    private Double parseToDouble(Object obj) {
+        if (obj instanceof Number) {
+            // 保留一位小数 (可选)
+            double val = ((Number) obj).doubleValue();
+            return (double) Math.round(val * 10) / 10;
+        }
+        return 0.0;
+    }
 }
diff --git a/src/main/java/com/szu/afternoon3/platform/service/impl/AuthServiceImpl.java b/src/main/java/com/szu/afternoon3/platform/service/impl/AuthServiceImpl.java
index 6722d7d..1efd8ca 100644
--- a/src/main/java/com/szu/afternoon3/platform/service/impl/AuthServiceImpl.java
+++ b/src/main/java/com/szu/afternoon3/platform/service/impl/AuthServiceImpl.java
@@ -122,7 +122,7 @@ public class AuthServiceImpl implements AuthService {
      */
     private LoginVO buildLoginVO(User user, boolean isNewUser) {
         // 生成 JWT Token
-        String token = jwtUtil.createToken(user.getId());
+        String token = jwtUtil.createToken(user.getId(), user.getRole());
 
         LoginVO vo = new LoginVO();
         vo.setToken(token);
@@ -148,14 +148,17 @@ public class AuthServiceImpl implements AuthService {
 
     @Override
     public void sendEmailCode(String email) {
-        // Redis Key 设计: verify:code:{email}
-        // 例如: verify:code:test@qq.com
+        // Redis Key 设计
         String redisKey = "verify:code:" + email;
-
-        // 1. 防刷校验 (Rate Limiting): 检查是否有 TTL，如果 TTL > 4分30秒 (说明刚发过不到30秒)，拦截
-        // 或者简单点：设置一个额外的 key "verify:limit:email" 有效期 60s
         String limitKey = "verify:limit:" + email;
-        if (redisTemplate.hasKey(limitKey)) {
+
+        // 1. [核心修复] 防刷校验 (Rate Limiting) - 原子操作
+        // 尝试设置占位符，有效期 60 秒。
+        // 如果 Key 不存在，设置成功返回 true；如果 Key 已存在，设置失败返回 false。
+        Boolean isAllowed = redisTemplate.opsForValue().setIfAbsent(limitKey, "1", 60, TimeUnit.SECONDS);
+
+        if (Boolean.FALSE.equals(isAllowed)) {
+            // 抛出 429 操作太频繁
             throw new AppException(ResultCode.OPERATION_TOO_FREQUENT);
         }
 
@@ -169,22 +172,22 @@ public class AuthServiceImpl implements AuthService {
             message.setTo(email);
             message.setSubject("【映记】验证码");
             message.setText("您的验证码是：" + code + "。有效期为5分钟，请勿泄露给他人。");
+
             mailSender.send(message);
+
             log.info("邮件发送成功: {} -> {}", email, code);
         } catch (Exception e) {
+            // 发送失败时，务必删除限流 Key，否则用户 60秒内无法重试
+            redisTemplate.delete(limitKey);
             log.error("邮件发送失败", e);
             throw new AppException(ResultCode.MAIL_SEND_ERROR);
         }
 
         // 4. 存入 Redis (5分钟过期)
+        // 只有邮件发送成功才存码
         redisTemplate.opsForValue().set(redisKey, code, 5, TimeUnit.MINUTES);
-
-        // 5. 设置限流 Key (60秒过期)
-        redisTemplate.opsForValue().set(limitKey, "1", 60, TimeUnit.SECONDS);
     }
 
-    // AuthServiceImpl.java
-
     @Override
     public void resetPassword(UserPasswordResetDTO dto) {
         // 1. 校验验证码 (复用之前的逻辑)
diff --git a/src/main/java/com/szu/afternoon3/platform/service/impl/PostServiceImpl.java b/src/main/java/com/szu/afternoon3/platform/service/impl/PostServiceImpl.java
index d1e5cdc..f15583d 100644
--- a/src/main/java/com/szu/afternoon3/platform/service/impl/PostServiceImpl.java
+++ b/src/main/java/com/szu/afternoon3/platform/service/impl/PostServiceImpl.java
@@ -13,6 +13,7 @@ import com.szu.afternoon3.platform.entity.mongo.UserFollowDoc;
 import com.szu.afternoon3.platform.event.PostCreateEvent;
 import com.szu.afternoon3.platform.event.PostDeleteEvent;
 import com.szu.afternoon3.platform.event.PostUpdateEvent;
+import com.szu.afternoon3.platform.event.UserSearchEvent;
 import com.szu.afternoon3.platform.exception.AppException;
 import com.szu.afternoon3.platform.exception.ResultCode;
 import com.szu.afternoon3.platform.repository.*;
@@ -116,9 +117,10 @@ public class PostServiceImpl implements PostService {
     @Override
     public Map<String, Object> searchPosts(String keyword, Integer page, Integer size) {
         Long currentUserId = UserContext.getUserId();
+
+        // 【修复】改为发布事件，真正实现异步解耦，不阻塞主搜索线程
         if (currentUserId != null && StrUtil.isNotBlank(keyword)) {
-            // 调用内部辅助方法保存历史 (使用 Upsert 逻辑，存在则更新时间，不存在则插入)
-            saveSearchHistoryAsync(currentUserId, keyword);
+            eventPublisher.publishEvent(new UserSearchEvent(this, currentUserId, keyword));
         }
 
         int pageNum = (page == null || page < 1) ? 0 : page - 1;
@@ -128,49 +130,36 @@ public class PostServiceImpl implements PostService {
             return buildResultMap(Page.empty(PageRequest.of(pageNum, pageSize)));
         }
 
-        // 1. 使用 Jieba 处理用户的搜索词
-        // 用户搜 "深大美食" -> 转换成 "深大 美食" (Mongo会理解为 OR 关系)
+        // ... 以下原有的搜索逻辑保持不变 ...
+        // 1. Jieba 分词
         String searchString = searchHelper.analyzeKeyword(keyword);
-
-        // 兜底：如果分词后为空 (比如用户只输入了标点)，就用原词
         if (StrUtil.isBlank(searchString)) {
             searchString = keyword;
         }
 
-        // 2. 构建全文检索条件
-        // matching() 会自动去匹配 PostDoc 中带有 @TextIndexed 的字段 (即 searchTerms)
+        // 2. 构建查询
         TextCriteria criteria = TextCriteria.forDefaultLanguage().matching(searchString);
-
-        // 3. 构建查询对象
-        // sortByScore: 按匹配度排序 (相关性高的在前，比如同时包含 "深大" 和 "美食" 的)
         Query query = TextQuery.queryText(criteria).sortByScore();
-
-        // 4. 叠加状态过滤
         query.addCriteria(Criteria.where("isDeleted").is(0));
         query.addCriteria(Criteria.where("status").is(1));
 
-        // 5. 分页
         Pageable pageable = PageRequest.of(pageNum, pageSize);
         query.with(pageable);
 
-        // 6. 执行
         long total = mongoTemplate.count(query, PostDoc.class);
-        List<PostDoc> list = mongoTemplate.find(query, PostDoc.class);
+        List<PostDoc> list;
 
-        // 降级逻辑,使用正则
+        // 降级逻辑
         if (total == 0) {
-            // log.info("Text Index 未命中，降级为 Regex 搜索: {}", keyword);
             query = new Query();
             String safeKeyword = java.util.regex.Pattern.quote(keyword);
             String regex = ".*" + safeKeyword + ".*";
 
-            // 注意：这里要搜 title, content, tags，不要搜 searchTerms (因为 searchTerms 是切碎的)
             query.addCriteria(new Criteria().orOperator(
                     Criteria.where("title").regex(regex, "i"),
                     Criteria.where("content").regex(regex, "i"),
                     Criteria.where("tags").regex(regex, "i")
             ));
-
             query.addCriteria(Criteria.where("isDeleted").is(0));
             query.addCriteria(Criteria.where("status").is(1));
             query.with(pageable);
@@ -184,27 +173,6 @@ public class PostServiceImpl implements PostService {
         return buildResultMap(new PageImpl<>(list, pageable, total));
     }
 
-    private void saveSearchHistoryAsync(Long userId, String keyword) {
-        try {
-            // 1. 定义查询条件: userId + keyword
-            Query query = new Query(Criteria.where("userId").is(userId).and("keyword").is(keyword));
-
-            // 2. 定义更新: 更新时间
-            Update update = new Update();
-            update.set("updatedAt", java.time.LocalDateTime.now());
-            // 如果是新插入，Mongo会自动设置 userId 和 keyword (因为在Query里)
-            // 但为了保险，显式setOnInsert一下
-            update.setOnInsert("userId", userId);
-            update.setOnInsert("keyword", keyword);
-
-            // 3. 执行 Upsert (存在则更新时间，不存在则插入)
-            mongoTemplate.upsert(query, update, SearchHistoryDoc.class);
-        } catch (Exception e) {
-            // 搜索历史保存失败不应影响主业务，打印日志即可
-            // log.warn("保存搜索历史失败: {}", e.getMessage());
-        }
-    }
-
     @Override
     public List<String> getSearchHistory(Long userId) {
         // 按时间倒序，取前 10 条
diff --git a/src/main/java/com/szu/afternoon3/platform/util/JwtUtil.java b/src/main/java/com/szu/afternoon3/platform/util/JwtUtil.java
index 7b83254..1ca16e2 100644
--- a/src/main/java/com/szu/afternoon3/platform/util/JwtUtil.java
+++ b/src/main/java/com/szu/afternoon3/platform/util/JwtUtil.java
@@ -14,9 +14,10 @@ public class JwtUtil {
     @Value("${szu.jwt.secret}")
     private String secretKey;
 
-    public String createToken(Long userId) {
+    public String createToken(Long userId, String role) {
         return JWT.create()
                 .setPayload("userId", userId)
+                .setPayload("role", role)
                 .setExpiresAt(new Date(System.currentTimeMillis() + 1000 * 60 * 60 * 24 * 7)) // 7天
 //                .setExpiresAt(null) // TODO 开发阶段设置为不过期好了
                 .setKey(secretKey.getBytes(StandardCharsets.UTF_8))
diff --git a/src/main/java/com/szu/afternoon3/platform/vo/AdminUserDetailVO.java b/src/main/java/com/szu/afternoon3/platform/vo/AdminUserDetailVO.java
new file mode 100644
index 0000000..4ecd110
--- /dev/null
+++ b/src/main/java/com/szu/afternoon3/platform/vo/AdminUserDetailVO.java
@@ -0,0 +1,42 @@
+package com.szu.afternoon3.platform.vo;
+
+import lombok.Data;
+import java.time.LocalDateTime;
+
+@Data
+public class AdminUserDetailVO {
+    // ==========================================
+    // 1. 基础信息 (PostgreSQL)
+    // ==========================================
+    private Long id;
+    private String email;
+    private String nickname;
+    private String avatar;
+    private String bio;
+    private Integer gender; // 0:保密, 1:男, 2:女
+    private String region;
+    private LocalDateTime registerTime;
+    private Integer status; // 账号状态 1:正常 0:封禁
+
+    // ==========================================
+    // 2. 社区活跃度 (主动数据 - 他做了什么)
+    // ==========================================
+    private Long postCount;          // 发布帖子数
+    private Long followCount;        // 关注人数
+
+    private Long givenLikeCount;     // 发出的点赞数 (他赞了别人多少次)
+    private Long givenCollectCount;  // 发出的收藏数
+    private Long givenCommentCount;  // 发出的评论数 (他评论了别人多少次) [新增]
+    private Long givenRateCount;     // 发出的评分数 (他给多少帖子打过分) [新增]
+
+    // ==========================================
+    // 3. 社区影响力 (被动数据 - 别人对他做了什么)
+    // ==========================================
+    private Long fanCount;             // 粉丝数
+
+    private Long receivedLikeCount;    // 获得的赞总数 (所有帖子获赞之和)
+    private Long receivedCollectCount; // 获得的收藏总数
+    private Long receivedCommentCount; // 获得的评论总数 (所有帖子评论之和) [新增]
+
+    private Double avgPostScore;       // 帖子平均得分 (他所有帖子的评分均值)
+}
\ No newline at end of file
diff --git a/src/test/java/com/szu/afternoon3/platform/controller/AdminControllerTest.java b/src/test/java/com/szu/afternoon3/platform/controller/AdminControllerTest.java
new file mode 100644
index 0000000..4f17502
--- /dev/null
+++ b/src/test/java/com/szu/afternoon3/platform/controller/AdminControllerTest.java
@@ -0,0 +1,264 @@
+package com.szu.afternoon3.platform.controller;
+
+import cn.hutool.core.collection.ListUtil;
+import cn.hutool.crypto.digest.BCrypt;
+import cn.hutool.json.JSONUtil;
+import com.szu.afternoon3.platform.common.RedisKey;
+import com.szu.afternoon3.platform.dto.*;
+import com.szu.afternoon3.platform.entity.User;
+import com.szu.afternoon3.platform.entity.mongo.PostDoc;
+import com.szu.afternoon3.platform.entity.mongo.UserFollowDoc;
+import com.szu.afternoon3.platform.mapper.UserMapper;
+import com.szu.afternoon3.platform.repository.PostRepository;
+import com.szu.afternoon3.platform.repository.UserFollowRepository;
+import com.szu.afternoon3.platform.util.JwtUtil;
+import org.junit.jupiter.api.AfterEach;
+import org.junit.jupiter.api.Assertions;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.DisplayName;
+import org.junit.jupiter.api.Test;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
+import org.springframework.boot.test.context.SpringBootTest;
+import org.springframework.data.mongodb.core.MongoTemplate;
+import org.springframework.data.redis.core.StringRedisTemplate;
+import org.springframework.http.MediaType;
+import org.springframework.test.web.servlet.MockMvc;
+import org.springframework.transaction.annotation.Transactional;
+
+import java.time.LocalDateTime;
+import java.util.List;
+
+import static org.hamcrest.Matchers.hasSize;
+import static org.hamcrest.Matchers.is;
+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
+import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print;
+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
+
+@SpringBootTest
+@AutoConfigureMockMvc
+@Transactional // 保证 PG 数据库回滚
+public class AdminControllerTest {
+
+    @Autowired
+    private MockMvc mockMvc;
+
+    @Autowired
+    private UserMapper userMapper;
+    @Autowired
+    private JwtUtil jwtUtil;
+    @Autowired
+    private MongoTemplate mongoTemplate;
+    @Autowired
+    private PostRepository postRepository;
+    @Autowired
+    private UserFollowRepository userFollowRepository;
+    @Autowired
+    private StringRedisTemplate redisTemplate;
+
+    private String adminToken;
+    private String userToken;
+    private Long adminId;
+    private Long normalUserId;
+    private Long targetUserId; // 用于测试删除的目标用户
+
+    @BeforeEach
+    public void setup() {
+        // 1. 清理 MongoDB (PG 会自动回滚)
+        mongoTemplate.dropCollection(PostDoc.class);
+        mongoTemplate.dropCollection(UserFollowDoc.class);
+
+        // 2. 创建管理员账号
+        User admin = new User();
+        admin.setEmail("admin@szu.edu.cn");
+        admin.setNickname("AdminUser");
+        String hashed = BCrypt.hashpw("123456");
+        admin.setPassword(hashed);
+        admin.setRole("ADMIN"); // 关键：角色为 ADMIN
+        admin.setStatus(1);
+        userMapper.insert(admin);
+        this.adminId = admin.getId();
+        this.adminToken = "Bearer " + jwtUtil.createToken(admin.getId(), "ADMIN");
+
+        // 3. 创建普通用户 (尝试越权)
+        User user = new User();
+        user.setEmail("hacker@szu.edu.cn");
+        user.setNickname("Hacker");
+        user.setRole("USER"); // 关键：角色为 USER
+        user.setStatus(1);
+        userMapper.insert(user);
+        this.userToken = "Bearer " + jwtUtil.createToken(user.getId(), "USER");
+
+        // 4. 创建目标用户 (用于被删除/查看详情)
+        User target = new User();
+        target.setEmail("target@szu.edu.cn");
+        target.setNickname("TargetUser");
+        target.setRole("USER");
+        target.setStatus(1);
+        userMapper.insert(target);
+        this.normalUserId = target.getId();
+
+        // 5. 制造 MongoDB 数据 (用于测试聚合查询)
+        // 目标用户发了 2 个帖子
+        createPost(normalUserId, "Post A", 10, 1); // 10赞
+        createPost(normalUserId, "Post B", 5, 1);  // 5赞
+
+        // 目标用户被管理员关注 (测试粉丝数)
+        UserFollowDoc follow = new UserFollowDoc();
+        follow.setUserId(adminId);
+        follow.setTargetUserId(normalUserId);
+        follow.setCreatedAt(LocalDateTime.now());
+        userFollowRepository.save(follow);
+    }
+
+    @AfterEach
+    public void tearDown() {
+        mongoTemplate.dropCollection(PostDoc.class);
+        mongoTemplate.dropCollection(UserFollowDoc.class);
+    }
+
+    private void createPost(Long userId, String title, int likes, int status) {
+        PostDoc post = new PostDoc();
+        post.setUserId(userId);
+        post.setTitle(title);
+        post.setContent("Content of " + title);
+        post.setLikeCount(likes);
+        post.setStatus(status); // 1:发布, 0:审核中
+        post.setIsDeleted(0);
+        post.setCreatedAt(LocalDateTime.now());
+        postRepository.save(post);
+    }
+
+    // ==================== 1. 鉴权测试 ====================
+
+    @Test
+    @DisplayName("测试：普通用户访问后台接口应被拦截 (403)")
+    public void testPermissionDenied() throws Exception {
+        AdminUserSearchDTO dto = new AdminUserSearchDTO();
+        mockMvc.perform(post("/admin/user/list")
+                        .header("Authorization", userToken) // 使用普通用户 Token
+                        .contentType(MediaType.APPLICATION_JSON)
+                        .content(JSONUtil.toJsonStr(dto)))
+                .andExpect(status().isOk())
+                .andExpect(jsonPath("$.code").value(40302)) // PERMISSION_DENIED
+                .andExpect(jsonPath("$.message").value("非管理员无权操作"));
+    }
+
+    @Test
+    @DisplayName("测试：管理员登录成功并获取 Token")
+    public void testAdminLogin() throws Exception {
+        AccountLoginDTO loginDTO = new AccountLoginDTO();
+        loginDTO.setAccount("admin@szu.edu.cn");
+        loginDTO.setPassword("123456");
+
+        mockMvc.perform(post("/admin/auth/login")
+                        .contentType(MediaType.APPLICATION_JSON)
+                        .content(JSONUtil.toJsonStr(loginDTO)))
+                .andExpect(status().isOk())
+                .andExpect(jsonPath("$.code").value(200))
+                .andExpect(jsonPath("$.data.token").exists())
+                .andExpect(jsonPath("$.data.userInfo.userId").value(String.valueOf(adminId)));
+    }
+
+    // ==================== 2. 用户管理测试 ====================
+
+    @Test
+    @DisplayName("测试：用户列表聚合查询 (验证统计数据正确性)")
+    public void testGetUserList() throws Exception {
+        AdminUserSearchDTO dto = new AdminUserSearchDTO();
+        dto.setNickname("Target"); // 搜索目标用户
+
+        mockMvc.perform(post("/admin/user/list")
+                        .header("Authorization", adminToken)
+                        .contentType(MediaType.APPLICATION_JSON)
+                        .content(JSONUtil.toJsonStr(dto)))
+                .andDo(print())
+                .andExpect(status().isOk())
+                .andExpect(jsonPath("$.data.records", hasSize(1)))
+                // 验证统计数据：发了2个贴，总赞数10+5=15，粉丝数1(管理员关注了他)
+                .andExpect(jsonPath("$.data.records[0].postCount").value(2))
+                .andExpect(jsonPath("$.data.records[0].likeCount").value(15))
+                .andExpect(jsonPath("$.data.records[0].fanCount").value(1));
+    }
+
+    @Test
+    @DisplayName("测试：获取用户详情 (AdminUserDetailVO)")
+    public void testGetUserDetail() throws Exception {
+        mockMvc.perform(get("/admin/users/" + normalUserId)
+                        .header("Authorization", adminToken))
+                .andExpect(status().isOk())
+                .andExpect(jsonPath("$.data.nickname").value("TargetUser"))
+                .andExpect(jsonPath("$.data.receivedLikeCount").value(15)) // 验证被动影响力
+                .andExpect(jsonPath("$.data.fanCount").value(1));
+    }
+
+    @Test
+    @DisplayName("测试：删除用户及其关联数据 (验证异步清理)")
+    public void testDeleteUser() throws Exception {
+        AdminUserDeleteDTO dto = new AdminUserDeleteDTO();
+        dto.setReason("违规用户");
+
+        // 1. 执行删除
+        mockMvc.perform(post("/admin/user/" + normalUserId)
+                        .header("Authorization", adminToken)
+                        .contentType(MediaType.APPLICATION_JSON)
+                        .content(JSONUtil.toJsonStr(dto)))
+                .andExpect(status().isOk());
+
+        // 2. 验证 PG 用户已删除
+        Assertions.assertNull(userMapper.selectById(normalUserId), "PostgreSQL 中的用户应被删除");
+
+        // 3. 验证 Mongo 数据清理 (由于是异步 @Async，需要稍微等待)
+        Thread.sleep(1000);
+
+        long postCount = postRepository.count(); // 之前有2个贴
+        long followCount = userFollowRepository.count(); // 之前有1个关注
+
+        // 应该是 0，因为帖子作者被删了
+        Assertions.assertEquals(0, postCount, "该用户的帖子应该被级联删除");
+        // 应该是 0，因为关注关系的 targetUser 被删了
+        Assertions.assertEquals(0, followCount, "该用户的关注关系应该被级联删除");
+    }
+
+    // ==================== 3. 内容审核测试 ====================
+
+    @Test
+    @DisplayName("测试：内容审核列表与审核操作")
+    public void testAuditPost() throws Exception {
+        // 1. 创建一个待审核帖子
+        PostDoc pendingPost = new PostDoc();
+        pendingPost.setUserId(normalUserId);
+        pendingPost.setTitle("待审核");
+        pendingPost.setStatus(0); // 待审核
+        pendingPost.setIsDeleted(0);
+        postRepository.save(pendingPost);
+        String postId = pendingPost.getId();
+
+        // 2. 审核通过 (Pass)
+        AdminPostAuditDTO auditDTO = new AdminPostAuditDTO();
+        auditDTO.setStatus(1); // 通过
+        auditDTO.setReason("合规");
+
+        mockMvc.perform(post("/admin/post/" + postId + "/audit")
+                        .header("Authorization", adminToken)
+                        .contentType(MediaType.APPLICATION_JSON)
+                        .content(JSONUtil.toJsonStr(auditDTO)))
+                .andExpect(status().isOk());
+
+        // 3. 验证状态变更
+        PostDoc updatedPost = postRepository.findById(postId).orElseThrow();
+        Assertions.assertEquals(1, updatedPost.getStatus(), "帖子状态应变更为 1 (已发布)");
+
+        // 4. 审核拒绝 (Reject)
+        auditDTO.setStatus(2); // 拒绝
+        mockMvc.perform(post("/admin/post/" + postId + "/audit")
+                        .header("Authorization", adminToken)
+                        .contentType(MediaType.APPLICATION_JSON)
+                        .content(JSONUtil.toJsonStr(auditDTO)))
+                .andExpect(status().isOk());
+
+        updatedPost = postRepository.findById(postId).orElseThrow();
+        Assertions.assertEquals(2, updatedPost.getStatus(), "帖子状态应变更为 2 (拒绝)");
+    }
+}
\ No newline at end of file
diff --git a/src/test/java/com/szu/afternoon3/platform/controller/InteractionIntegrationTest.java b/src/test/java/com/szu/afternoon3/platform/controller/InteractionIntegrationTest.java
index d770074..2f021e4 100644
--- a/src/test/java/com/szu/afternoon3/platform/controller/InteractionIntegrationTest.java
+++ b/src/test/java/com/szu/afternoon3/platform/controller/InteractionIntegrationTest.java
@@ -72,7 +72,7 @@ public class InteractionIntegrationTest {
         this.userId = user.getId();
 
         // 4. 生成 Token
-        this.token = "Bearer " + jwtUtil.createToken(userId);
+        this.token = "Bearer " + jwtUtil.createToken(userId, "USER");
 
         // 5. 创建测试帖子
         PostDoc post = new PostDoc();
diff --git a/src/test/java/com/szu/afternoon3/platform/controller/NotificationIntegrationTest.java b/src/test/java/com/szu/afternoon3/platform/controller/NotificationIntegrationTest.java
index 4178732..5d0ed56 100644
--- a/src/test/java/com/szu/afternoon3/platform/controller/NotificationIntegrationTest.java
+++ b/src/test/java/com/szu/afternoon3/platform/controller/NotificationIntegrationTest.java
@@ -62,11 +62,11 @@ public class NotificationIntegrationTest {
         // 2. 创建两个测试用户 (PostgreSQL)
         // 发送者
         sender = createUser("Sender_XiaoQing");
-        senderToken = "Bearer " + jwtUtil.createToken(sender.getId());
+        senderToken = "Bearer " + jwtUtil.createToken(sender.getId(), "USER");
 
         // 接收者
         receiver = createUser("Receiver_YouYou");
-        receiverToken = "Bearer " + jwtUtil.createToken(receiver.getId());
+        receiverToken = "Bearer " + jwtUtil.createToken(receiver.getId(), "USER");
 
         // 3. 接收者发一篇帖子 (MongoDB)
         PostDoc post = new PostDoc();

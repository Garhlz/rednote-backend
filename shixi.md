# 实习速通指南

### 一、 八股文（精准押题版）

*说明：不要去背几百页的文档，只背下面这些“必死题”。*

#### 1. 语言篇：Go & C++ (你的双刀流)

你说你是半吊子，所以我们策略是：**C++ 负责算法和底层，Go 负责业务和并发。**

- **Go (重中之重，因为你简历有Go项目):**
  - **GMP 模型：** 必须滚瓜烂熟。P 和 M 的关系？G 什么时候会被抢占？（这是腾讯/字节必问）。
  - **GC (垃圾回收)：** 三色标记法？写屏障？STW (Stop The World) 什么时候发生？
  - **Map：** 为什么不是线程安全的？并发读写会panic吗？（答：会，要用 `sync.Map` 或加锁）。
  - **Channel：** 有缓冲和无缓冲的区别？向关闭的 channel 写数据会怎样？（Panic）。
- **C++ (辅助，体现内功):**
  - **虚函数：** 虚表指针存在哪？（对象头部）。
  - **智能指针：** `shared_ptr` 的引用计数线程安全吗？（计数本身安全，但对象读写不安全）。
  - **STL：** `vector` 扩容是 1.5 倍还是 2 倍？（GCC 是 2，VS 是 1.5）。

#### 2. 操作系统 (基于 xv6 - 你的最强盾牌)

*面试官问 OS，你就把话题往 xv6 引。*

- **虚拟内存 (Killer Question):**
  - *问：* 虚拟内存有什么用？
  - *答（结合 xv6）：* 隔离性。在 xv6 中，每个进程有独立的页表（pagetable），用户态映射低地址，内核态映射高地址（TRAMPOLINE）。
- **Copy-on-Write (COW):**
  - *核心：* `fork()` 时不复制物理页，只复制页表并将 PTE 设为只读。写发生时触发 Page Fault，再分配物理页。
  - *结合点：* xv6 的 `usertrap()` 函数里怎么捕获这个异常。
- **进程切换:**
  - `context switch` 保存了什么寄存器？（callee-saved registers）。

#### 3. 数据库 (基于 PG & 理论)

*既然 Bustub 没做完，PG 也不熟，那就死磕**“通用原理”**。*

- **索引 (必考):** 为什么用 B+ 树不用红黑树？（磁盘 IO 友好）。聚簇索引 vs 非聚簇索引？
- **事务 (ACID):**
  - *隔离性：* MVCC 是怎么实现的？（PG 是通过 `xmin`, `xmax` 隐藏字段来实现可见性判断的，这点一定要记住，和 MySQL 的 Undo Log 不一样）。
  - *原子性/持久性：* WAL (Write Ahead Log) 是什么？
- **Join 算法 (你的 PG 项目题):**
  - **Hash Join:** 适合大表+大表（等值连接）。
  - **Nested Loop:** 适合小表驱动大表。
  - **Symmetric Hash:** 适合流式数据（不用等整张表构建完 Hash 表就能出结果）。**记住这句话就能救命。**

#### 4. 计算机网络 (基础分)

- **TCP:** 三次握手丢了第一次怎么办？丢了第三次怎么办？
- **HTTP:** HTTPS 的 TLS 握手过程（RSA vs ECDHE）。
- **IO 多路复用 (Epoll):** LT (水平触发) vs ET (边缘触发) 的区别？（Go 的 Netpoller 底层是 ET 吗？其实是模拟的）。

------

### 二、 算法题 (战术执行)

**语言：** 现代 C++ (`auto`, `vector`, `lambda` 随便用)。

**刷题策略：**

1. **只刷 LeetCode Hot 100。** 别的地方不要看。
2. **分类击破：**
   - **链表：** 反转、环、合并（必考，必须 5 分钟 bug-free）。
   - **二叉树：** 层序遍历、最近公共祖先（LCA）。
   - **Top K：** 快排变形 / 堆（priority_queue）。
   - **LRU Cache：** 必须要能手写一个基于 `list` + `unordered_map` 的实现。

------

### 三、 项目升级 & 复习 (你的胜负手)

这里我帮你把 **Rednote** 和 **PG** 的策略再调整得“狡猾”一点。

#### 1. Rednote 后端 (微服务化版) —— **绝对主力**

这是你简历上最大的亮点，你要把它吹得像一个**“小型架构师作品”**。

- **架构叙事 (The Story):**
  - "为了解决社区私信/推送模块的高并发长连接压力，我将该模块从 Java 单体中**拆分**，使用 **Go** 重构。"
  - "利用 **Go** 的高并发特性（Goroutine）处理 WebSocket 连接，利用 **Java** 生态处理复杂的业务逻辑（DDD）。"
- **必杀技 (Go Sidecar):**
  - 你代码里那个 `sync-sidecar` 就是证据。
  - **gRPC:** 怎么定义 `.proto`？怎么生成代码？
  - **RabbitMQ:** 怎么保证消息不丢失？（生产端 Confirm，消费端 Ack，持久化）。
  - **Elasticsearch:** 倒排索引原理？（Term Dictionary -> Term Index）。

#### 2. MIT 6.S081 (xv6) —— **防守反击**

- **策略：** 只要面试官问 OS，你就说 "我在实现 xv6 内核时发现..."。
- **准备一个 Bug：** 面试官爱问 "你在这个项目里遇到的最难的 Bug 是什么？"
  - *剧本：* 在做 Lazy Allocation 时，忘记在 `uvmunmap` 里处理未分配的页面，导致 panic。这体现了你对页表项（PTE）状态位的理解。

#### 3. PostgreSQL Symmetric Hash —— **奇兵 (保留但降级)**

- **决策：** **写上去！** 哪怕是抄的，哪怕不熟。
- **为什么？** 因为 "PostgreSQL Kernel" 这几个字太吸睛了。它能把你和只会 CRUD 的学生区分开。
- **怎么苟？**
  - 把它放在简历的**"课程项目"**里，而不是"实习/开源经历"里（降低面试官期望）。
  - **只准备原理，不准备代码细节。**
  - 如果问得太深，你就说："这是课程大作业，主要关注算法逻辑实现，对 PG 存储引擎底层的 dirty page 落盘机制涉猎不深。"（诚实地划定边界）。





### 第一梯队：S 级（面试必问，死记硬背也要看懂）

*这些章节对应了 Go 面试中最核心的“三座大山”：调度、GC、并发。*

1. **6.5 调度器 (GMP 模型)** —— **⭐ 全书最重要章节**
   - **必读理由：** 面试官问 Go 为什么快、Go 的并发模型是什么，其实就是在问 GMP。
   - **关注点：** G、M、P 分别代表什么？M 和 P 怎么绑定？什么是“窃取任务 (Work Stealing)”？什么是“抢占式调度”？
2. **7.2 垃圾收集器 (GC)** —— **⭐ 必考**
   - **必读理由：** 所有带 GC 语言的必考题。
   - **关注点：** 三色标记法是什么？写屏障（Write Barrier）解决了什么问题？STW (Stop The World) 什么时候发生？
3. **6.4 Channel** —— **⭐ 必考**
   - **必读理由：** Go 哲学的核心体现。
   - **关注点：** Channel 的底层结构（环形队列 `hchan`）。向关闭的 Channel 写数据会发生什么（panic）？读数据会发生什么？
4. **3.2 切片 (Slice) & 3.3 哈希表 (Map)**
   - **必读理由：** 考察你对基本数据结构的掌控。
   - **关注点：** Slice 的扩容机制（1.18 版本前后有变化，注意看最新的）。Map 的扩容（增量扩容/等量扩容）和桶结构。**注意 Map 是线程不安全的。**

------

### 第二梯队：A 级（项目实战强相关，高频考点）

*这些章节能帮你解释“为什么你的 IM 系统选型 Go”以及解决实际代码坑。*

1. **6.6 网络轮询器 (Netpoller)**
   - **必读理由：** **你的 IM 项目核心。** 为什么 Go 写高并发网络服务（如推送、长连接）性能好？因为底层用了 I/O 多路复用（epoll/kqueue）。读懂这章，你就能跟面试官吹“Go 的 goroutine + epoll 网络模型”。
2. **6.1 上下文 (Context)**
   - **必读理由：** **微服务核心。** 你的 gRPC 调用、超时控制、链路追踪全靠 Context。面试常问：Context 是怎么取消 Goroutine 的？
3. **5.3 defer**
   - **必读理由：** 面试写代码时的“陷阱题”高发区。
   - **关注点：** defer 的执行顺序（栈，后进先出）。defer 和 return 谁先执行？（return 先赋值，defer 后执行）。
4. **4.2 接口 (Interface)**
   - **关注点：** `iface` 和 `eface` 的区别。接口为 nil 和 接口内的值为 nil 是一回事吗？（经典坑：不是一回事）。

------

### 第三梯队：B 级（有空再看，没空跳过）

- 5.1 for 和 range（了解一下循环变量的坑，虽然新版本修了，但老代码还有）。
- 5.2 select（了解一下随机选择机制）。
- 7.1 内存分配器（TCMalloc 思想，太复杂了，记住“多级缓存 mcache/mcentral/mheap”几个名词就行）。
- 5.4 panic 和 recover（知道不能跨协程 recover 就行）。

------

### ❌ 坚决不读（对实习面试 ROI 极低）

- **第一部分（预备知识）：** 编译原理、机器码生成。 *（除非你去面编译器组，否则别看）*
- **第四部分（进阶内容）：** 插件系统、元编程、标准库源码分析（JSON/HTTP/DB）。 *（面试很少问具体库的源码，除非你简历特意写了）*
- **3.4 字符串 / 3.1 数组：** 太简单，扫一眼即可。

**总结阅读路线图：** **先看 6.5 (GMP) -> 再看 7.2 (GC) -> 再看 6.4 (Channel) -> 穿插看 3.2/3.3 (数据结构)。** 搞定这这几章，你对 Go 的理解就足以应付腾讯/字节的实习面试了。加油！





### 第一部分：直接跳过 (占比 40%)

这些内容要么太基础（你已经会了），要么太陈旧（面试不问），要么太偏（DBA 才看）。

- **第 1-5 章 (SQL 基础):** 你能写 Bustub，说明 SQL 肯定没问题。**直接跳过。**
- **第 6-7 章 (数据库设计/范式):** ER 图、BCNF、3NF。除非你面试被问到“给教务系统设计表结构”，否则**不用看**。实战中大家都反范式设计。
- **第 8-9 章 (XML/应用开发):** XML、Servlet、Django...这些是上个世纪的 Web 开发，**直接跳过**。
- **第 10-11 章 (大数据/数据分析):** MapReduce 和数据挖掘。这部分不如看 DDIA 或者专门的大数据书。**跳过。**

------

### 第二部分：CMU 15-445 伴侣 (占比 30%) —— 配合代码食用

既然你在写数据库内核（Bustub），这几章是你写代码时的“理论说明书”。当你代码写不下去，或者不理解为什么 Bustub 要这么设计时，翻这几章。

#### **第 13 章：数据存储结构 (重点)**

- **关注点：**
  - **13.3 文件组织:** 堆文件 (Heap File) vs 顺序文件。Bustub 里 Page 的布局就是这一章的具象化。
  - **13.5 缓冲区管理器 (Buffer Manager):** 你写的 LRU/Clock 替换策略，理论基础就在这。
  - **13.6 面向列的存储:** 了解一下列存（Parquet/ClickHouse），这是面试加分项。

#### **第 14 章：索引 (重点)**

- **关注点：**
  - **14.3 B+树:** 你代码的核心。
  - **14.8 写优化索引结构 (LSM 树):** **这是必读中的必读！** * Bustub 是 B+ 树，但你的 AI Agent 项目用的 **Milvus (向量库)** 以及 **RocksDB** 用的全是 **LSM-Tree**。
    - **面试考点：** B+ 树和 LSM 树在读写性能上的 Trade-off 是什么？

#### **第 19 章：恢复系统 (Recovery) —— 全书最难**

- **关注点：**
  - **19.3 日志 (WAL):** 为什么先写日志再写磁盘？
  - **19.9 ARIES 算法:** 这是数据库恢复技术的皇冠明珠。Bustub 的 Project 4 (Recovery) 就是实现 ARIES 的简化版。这章非常硬核，**只有做 Project 4 时才需要精读**。

------

### 第三部分：架构师进阶 (占比 30%) —— 对应分布式与高并发

这部分内容是 **后端面试 SSP** 的核心考点，也是连接 DDIA 的桥梁。

#### **第 18 章：并发控制 (Concurrency Control)**

- **为什么重要：** 你在 15-445 里可能只实现了 2PL（两阶段锁），但现实世界（MySQL/Postgres）用的是 MVCC。
- **精读章节：**
  - **18.1 - 18.2:** 锁协议、死锁检测（基础）。
  - **18.7 - 18.8 (多版本机制 MVCC / 快照隔离):** **超级重点！**
  - 面试官问：“MySQL 的 Repeatable Read 是怎么实现的？” 答案就在这两节里。

#### **第 21 章：并行和分布式存储**

- **精读章节：**
  - **21.2 数据分区 (Partitioning):** 一致性哈希。
  - **21.3 偏斜处理 (Skew):** 数据倾斜怎么办？（DDIA 也讲了这个，可以对照看）。

#### **第 23 章：并行和分布式事务处理 (面试天花板)**

- **精读章节：**
  - **23.2.1 两阶段提交 (2PC):** 分布式事务的基础。
  - **23.8 分布式共识 (Consensus):**
    - **23.8.2 Paxos**
    - **23.8.3 Raft**
  - 这部分内容非常抽象，如果你觉得看书吃力，建议配合 **Raft 论文** 或者 **MIT 6.824 视频** 一起看。

------

### 总结：你的“帆船书”阅读清单

不要把它当课本，把它当**字典**和**深度解析**。

1. **配合 15-445 做项目时：** 翻看 **Ch 13 (存储)**, **Ch 14 (索引)**, **Ch 19 (恢复)**。特别是 **14.8 (LSM树)**，一定要看，为了你的 AI 项目。
2. **准备后端面试时：** 精读 **Ch 18 (并发控制 - MVCC)** 和 **Ch 23 (分布式事务 - 2PC/Raft)**。这两章读透了，国内大厂的数据库面试题基本难不倒你。
3. **其他的：** 没时间就别看了，性价比不高。

这样一剪裁，这本书你需要读的可能只有 200 页左右，是不是压力小多了？

## 项目微服务升级计划
### 第一阶段：协议先行 (Protobuf & gRPC) — 预计 1 周

微服务的核心不在于“拆”，而在于“通信”。

- 定义接口：

  - 不要直接写代码，先在项目根目录创建 proto 文件夹。

  - 将 Interaction (点赞/收藏) 模块作为突破口。定义一个 interaction.proto 文件，包含 Like、Unlike、GetLikeCount 等 RPC 方法。

- 跨语言通信：

  - 使用 goctl (go-zero 命令行工具) 生成 Go 端的 RPC 骨架。

  - 在 Java (Spring Boot) 端引入 grpc-spring-boot-starter。

  - 目标：实现 Java 业务层调用 Go 编写的 RPC 服务。

- 最佳实践：

    - 学习点：理解 Protobuf 为什么比 JSON 快（二进制编码 vs 文本编码），掌握 gRPC 的四种通信模式。

### 第二阶段：服务抽取 (go-zero 落地) — 预计 2 周

利用 Go 的并发优势处理高频 IO。

- 迁移 Interaction 逻辑：

  - 将原本在 InteractionServiceImpl.java 中的 Redis 写缓冲（Write-Behind Pattern）逻辑迁移到 Go RPC 服务中。

  - 技术升级：在 Go 中利用 sqlx 或 ent 框架处理数据库，利用 go-zero 内置的 collection.Cache 管理热点缓存。

- 引入 etcd：

  - 在 docker-compose-dev.yml 中添加 etcd 容器。

  - 配置 Go 服务自动注册到 etcd，配置 Java 端通过 etcd 发现 Go RPC 服务。

- 最佳实践：

  - 学习点：服务发现的原理（心跳检测、租约机制）、go-zero 的自适应限流与熔断机制。

### 第三阶段：可观测性升级 — 预计 1 周

这是实习面试中区分“小打小闹”与“工程化思维”的关键。

- 链路追踪 (Tracing)：

  - 部署 Jaeger 或 Zipkin。

  - 在 go-zero 和 Spring Boot 中同时开启 OpenTelemetry 支持。

  - 目标：在界面上能看到一个“发帖”请求如何经过 Java API，触发 Go RPC 统计，最后通过 MQ 同步数据的全链路耗时。

- 指标监控 (Metrics)：

  - 利用你现有的 Prometheus + Grafana，接入 Go 服务的运行时指标（协程数、GC 耗时）。

### 第四阶段：容器编排 (K8s 入门) — 预计 2 周

将你的 Docker 部署方案升级为云原生架构。

- 从 Docker 到 K8s：

  - 学习编写 Deployment、Service 和 Ingress 的 YAML 文件。

  - 本地演练：使用 Minikube 部署你的一整套服务（Java 业务 + Go RPC + etcd + Redis）。

- 配置中心升级：

  - 尝试将 .env 或 application.yml 中的硬编码配置 迁移到 K8s 的 ConfigMap 或 Secret 中。